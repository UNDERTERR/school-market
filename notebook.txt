该笔记本将体现整个项目的心路历程，帮助简历的优化：
**核心思想，什么业务=》需要什么技术=》可以解决什么问题**
***改成校园二手物品买卖平台：二人转 school-market
***(普通的物品买卖:gulimall项目)
***(类onlyfans：校园学习笔记订阅系统，卖者可以选择一些为免费，而另一些为付费，订阅者可以按月订阅或按单订阅（价格由卖家设置），
    随时可以取消，如果一个卖家半个月没有发布过笔记，可以自动提醒是否取消订阅
    有评分系统，和举报系统
    支持word/pdf/多种图片格式/视频)
------------------------------------------------------------------------------------------------------------------------------

1.本项目每个微服务单独配置版本，根项目只负责汇聚，便于后期可能的扩展导致版本更替冲突

2.两种序列化：对外用JSON，对内用字节流！
    如：redis、openfeign、mq等需要字节流

3.#serialVersionUID用于在序列化和反序列化过程中验证类的版本一致性

4.#hibernate validator:
    @Validated({AddGroup.class}) 告诉Spring当前操作场景
    字段级规则：groups = {AddGroup.class} 定义字段在什么场景下需要校验

5.数据库不使用外键：
    1）性能 2）微服务，不同服务数据库存放位置可能不一 3）后期不易分库分表

6.- 性能：Dubbo高性能 vs Feign通用性
  - 序列化：Dubbo二进制 vs Feign JSON

7. paginationInterceptor.setCountSqlParser(new JsqlParserCountOptimize(true));优化查询，提升50%

8.#使用spring actuator监控spring服务

9.重构分布式缓存架构，采用Redisson分布式锁+双重检查机制解决高并发缓存击穿问题，
  通过Spring Cache+Redis实现多级缓存，将商品分类查询响应时间从500ms优化至50ms，数据库查询压力降低80%。

10.设计Redis Hash存储购物车数据，结合Pipeline批量操作技术，实现购物车操作响应时间控制在100ms以内，支持日均10万+订单处理。

11.- getLock() - 本地操作，只是创建对象    - tryLock() - 网络操作，向Redis发送SETNX命令

12.编写完整的单元测试套件，包括业务逻辑测试、边界条件测试、集成测试，测试覆盖率达到85%以上，确保代码质量和系统稳定性。

13.#Spring Cloud Sleuth生成分布式链路追踪信息，通过Zipkin收集和展示调用链路

14.线程池拒绝策略：1. AbortPolicy（默认）// 直接抛出异常// 使用场景：需要明确知道任务被拒绝
                2. CallerRunsPolicy// 由提交任务的线程执行// 使用场景：需要保证所有任务都被执行
                3. DiscardPolicy// 静默丢弃任务// 使用场景：允许丢失部分任务
                4. DiscardOldestPolicy// 丢弃队列中最老的任务// 使用场景：优先执行新任务

15.重构商品SPU保存流程，通过CompletableFuture并行处理和批量操作，将数据库操作次数从18次减少至9次，保存耗时从3秒优化至1秒，性能提升67%；
实现分层保存策略，核心数据同步保存，扩展数据异步处理，提升系统响应速度。

16.#new TypeReference<MemberAddressVo>()用于解决Java泛型类型擦除问题

17.设计库存工作单机制,并采用乐观锁机制解决高并发库存超卖问题，确保数据一致性(这里的锁更像是消耗某个事物)

18.实现防重复解锁策略，保障高并发场景下的库存准确性

19.MD5：123456 → e10adc3949ba59abbe56e057f20f883e（固定值，可被彩虹表破解）
   BCrypt：123456 → $2a$10$【随机盐】+【哈希】（每次盐不同，无法预计算攻击）
            ↑ 即使两个用户密码都是123456，存的内容完全不同

20.RequestContextHolder.setRequestAttributes(requestAttributes);
   ：CompletableFuture会新开一个线程，在使用feign时需要知道http请求上下文，，所以要提前get请求属性，然后在future中set

21.对比Seata与MQ最终一致性方案，决定基于RabbitMQ实现事件驱动的最终一致性，替代传统的强一致性事务

22.企业级SQL优化策略：
1. 索引优化
- 复合索引： 根据查询频率调整字段顺序 (status,create_time)
- 覆盖索引： 避免回表，提升查询效率
- 索引失效场景： 函数操作、类型转换、LIKE前缀匹配
2. 查询重写
-- 避免：SELECT * 
-- 推荐：SELECT id,name,status WHERE status=1
-- 避免：子查询
-- 推荐：LEFT JOIN
3. 分库分表
- 垂直分表： 大字段分离（如content、blob）
- 水平分表： 按时间、用户ID分片
- 读写分离： 主从架构，查询走从库
4. 缓存策略
- Redis缓存： 热点数据TTL设置
- 本地缓存： Caffeine/Guava Cache
- 缓存预热： 系统启动时加载热点数据
5. 数据库配置
- 连接池： HikariCP参数调优
- 慢查询监控： 开启slow_query_log
- 执行计划分析： EXPLAIN查看cost
6. 架构层面
- ES搜索： 复杂查询用Elasticsearch
- 数据归档： 历史数据迁移
- 异步处理： MQ解耦复杂查询